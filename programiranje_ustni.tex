\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
 
        {\Large\textbf{Programiranje I}}
 
        \vspace{0.5cm}
        \textit{izpiski s predavanj}
             
        \vspace{15cm}
 
        \textit{Nace Kovačič}             
    \end{center}
 \end{titlepage}
\subsection*{\texttt{TO DO}}
\begin{itemize}
    \item \texttt{regularni izrazi - sklici na skupine}
    \item \texttt{zajem podatkov - normalizacija podatkov}
    \item \texttt{analiza podatkov - transformatcija razpredelnic}
    \item \texttt{analiza podatkov - vektorizacija}
    \item \texttt{uvod v ocaml - parametrični polimorfizem}
    \item \texttt{funkcijsko programiranje - anonimne funkcije}
    \item \texttt{funkcijsko programiranje - delna aplikacija funkcij in curryirane funkcije}
    \item \texttt{funkcijsko programiranje - curryiranje}
\end{itemize}

\newpage
\subsection*{regularni izrazi}
\textit{neko zaporedje znakov, ki opisuje vzorec v besedilu}
\begin{itemize}
    \item obstajajo boljša orodja za pridobivanje podatkov s spletne strani (\textit{beautiful soup})
    \item v VSCodu lahko iščemo \textit{navadno besedilo} ali pa \textit{regularne izraze}, ki so podani v iskalniku (če vključimo možnost \textit{.*})
\end{itemize}
\subsubsection*{\textit{legenda osnovnih znakov}}
\textbf{.} \dotfill katerikoli znak \\
\textbf{\textbackslash .} \dotfill pika \\
\textbf{\textbackslash \textbackslash} \dotfill backslash \\
\textbf{\textbackslash d} \dotfill števka\footnote{enakovredno izrazu \textbf{[0-9]}} \\
\textbf{\textbackslash D} \dotfill komplement števk \\
\textbf{\textbackslash w} \dotfill alfanumerični znak \\
\textbf{\textbackslash W} \dotfill komplement alfanumeričnih znakov \\
\textbf{\textbackslash s} \dotfill whitespace \footnote{presledek, tab, etc.} \\
\textbf{\textbackslash S} \dotfill komplement whitespace -a \\
\textbf{.DOTALL} \dotfill pojdi tudi čez nove vrstice\newline
\begin{itemize}
    \item če želimo, da se vzorec ponovi vsaj \textit{n - krat}, ga damo v \textit{zavite oklepaje}
    \item v \textit{oglate oklepaje} vstavimo znake, ki jih želimo poiskati
    \item če želimo, da določenih znakov ne najde, uporabimo \textit{[\string^znaki]}
    \item če želimo poiskati več besed, jih damo v \textit{oglate oklepaje}, mednje pa vstavimo \textit{\vline}
    \item če želimo poiskati vse znake med dvema vrednostima uporabimo \textit{vezaj}
    \item če mora biti znak na \textit{začetku}, napišemo predenj \textit{\string^}
    \item če mora biti znak na \textit{koncu}, napišemo na konec \textit{\$}
\end{itemize} \pagebreak
\subsubsection*{\textit{ponovitve elementov}}
\textbf{?} \dotfill 0 ali 1 \\
\textbf{+} \dotfill 1 ali več \\
\textbf{*} \dotfill 0 ali več \footnote{\textit{+} in \textit{*} imata \textit{skromni} in \textit{požrešni} način}
\subsubsection*{\textit{skupine}}
\textit{nastanejo, ko damo nekaj v oklepaje}
\begin{itemize}
    \item skupin je lahko več
    \item lahko jih poimenujemo \textit{(?P$<$naslov$>$)}
\end{itemize} 
\subsubsection*{\textit{json}}
\begin{itemize}
    \item podatke o filmih je pametno shraniti v \textit{json} datoteko
    \item \textit{standarden tekstovni format}, ki izhaja iz java-scripta
    \item podpira objekte
    \item manjkajočo vrednost označimo z \textit{null}
    \item iz \textit{Pythona} v \textit{json} dobimo s funkcijo \textbf{json.dumps}
    \item iz \textit{jsona} v \textit{Python} dobimo s funkcijo \textbf{json.loads}
\end{itemize}
\subsubsection*{\textit{csv}}
\begin{itemize}
    \item bolje od \textit{jsona} za statistično analizo, saj so podatki podani tabelarično
    \item v zgornji vrstici so navadno \textit{naslovi stolpcev}
    \item vsaka vrstica predstavlja svoj \textit{podatek} \footnote{recimo vsak film je v svoji vrstici}
\end{itemize}
\subsubsection*{\textit{Pythonove knjižnice za obdelavo podatkov}}
\subsubsection*{\textit{re}}
\textbf{re.findall(vzorec, besedilo)} \dotfill poišče vse ponovitve vzorca v besedilu
\textbf{re.groupdict} \dotfill naredi slovar naših skupin \\ 
\textbf{re.groupiter} \dotfill iterator \textit{groupdict} \\
\textbf{re.finditer} \dotfill PREVERI, KAJ NAREDI
\subsubsection*{\textit{requests}}
\textbf{requests.get(url)} \dotfill dobimo odziv spletne strani\footnote{dobimo objekt tipa \textit{Response}} \\
\textbf{requests.get.(url).text} \dotfill vrne \textit{vsebino} spletne strani \\
\subsubsection*{\textit{csv}}
\textbf{csv.DictWriter(csv, fieldnames)} \dotfill slovar zapišemo v ustrezna polja \\
\textbf{csv.DictWriter(csv, fieldnames).writeheader()} \dotfill izpiši glavo \\
\subsubsection*{\textit{pandas}}
\textit{knjižnica za analizo podatkov}
\begin{itemize}
    \item pogosto uporabljamo skupaj z \textit{Jupyterjem}
    \item \textit{Jupyter} je vizualno okolje za delo analizo podatkov v Pythonu \footnote{prednost je v tem, da lahko Python datoteko izvajamo sproti, da nam ni treba ponovno restartat vsakič, ko kaj spremenimo}
    \item \textit{Jupyter notebook} je sestavljen iz več celic \footnote{koda (\textit{Python}) in besedilo (\textit{Markdown})}
\end{itemize}
\textbf{pd.read\_csv} \dotfill prebere csv datoteko in prikaže tabelo \\ 
\textbf{pd.read.head(n)} \dotfill dobimo \textit{prvih n} elementov \\
\textbf{pd.read.tail(n)} \dotfill dobimo \textit{zadnjih n} elementov \\
\textbf{pd.read[ime\_stolpca]} \dotfill dostopamo do posameznega stolpca \\
\textbf{pd.read[seznam imen]} \dotfill dostopamo do razpredelnice stolpcev \\
\textbf{pd.read.iloc[i]} \dotfill dostopamo do vrednosti na \textit{i - tem} mestu \\
\textbf{pd.read.loc[k]} \dotfill dostopamo do ključa \textit{k} \\
\textbf{pd.read.groupby} \dotfill \textit{razpredelnice}, kjer so vrstice združene glede na lastnost\\
\textbf{pd.read.count(pogoj)} \dotfill štejemo \textit{ponovitve} \\
\textbf{pd.read.size()} \dotfill pove, koliko je \textit{vnosov}, ne glede na dane podatke\\ 
\textbf{pd.read.merge(stolpci)} \dotfill dve tabeli \textit{združi} po stolpcih z istimi imeni\\
\textbf{pd.read.join()} \dotfill PREVERI \\
\textbf{pd.read.mean()} \dotfill izračuna \textit{povprečje} \\
\textbf{pd.read.sort\_values()} \dotfill \textit{uredi} po velikosti\\

Vrednosti v stolpcih lahko tudi \textit{filtriramo} z \textit{logičnimi vrednostmi}. Stolpce lahko tudi urejamo po vrednostih (\textit{naraščajoče} ali \textit{padajoče}). \\

Grafe rišemo z \textit{\%matplotlib inline}, tako, da uporabimo \textbf{.plot()}. \textit{Razsevni diagram} dobimo z \textbf{plot.scatter()}.
\pagebreak
\subsubsection*{\textit{naivni Bayesov kvantifikator}}
\textit{enostaven primer strojnega učenja}
\begin{itemize}
    \item odločamo se, ali nekaj pripada nekemu razredu ali ne \footnote{uporabno za \textit{spam}}
\end{itemize}
Zanima nas verjetnost dogodka $D_i$, ob pogoju, da vsebuje korene $K_1, \cdots, K_n$.
$$
P(D_i | K_1 \cap \cdots \cap K_n)
$$
Uporabimo \textbf{\textit{Bayesov izrek}}
$$
P(A|B) = \frac{P(A \cap B)}{P(B)} = \frac{P(B|A) \cdot P(A)}{P(B)}
$$
Velja
$$
P(D_i | K_1 \cap \cdots K_n) = \frac{P(K_1 \cap \cdots \cap K_n | D_i)\cdot P(D_i)}{P(K_1 \cap \cdots \cap K_n)}
$$
Ker je klasifikator naiven, velja
$$
P(K_1 \cap \cdots \cap K_n | D_i) = P(K_1 | D_i) \cdot \cdots \cdot P(K_n | D_i)
$$
oz.
$$
P(D_i | K_1 \cap \cdots \cap K_n) = \frac{P(K_1 | D_i) \cdot \cdots \cdot P(K_n | D_i) \cdot P(D_i)}{P(K_1 \cap \cdots \cap K_n)}
$$
\newpage
\subsection*{OCaml}
\textit{funkcijsko programiranje}
\begin{itemize}
    \item vrednosti definiramo z \textit{let}
    \item presledki niso pomembni
    \item komentarje pišemo v \textit{oklepaje} in \textit{zvezdice}
    \item v interaktivni konzoli damo na koncu \textit{;;}
    \item ima zelo rad \textit{tipe}
    \item vrstni red je vedno ime\_funkcije prva\_spremenljivka druga\_spremenljivka \footnote{temu pravilu pravimo \textit{aplikacija}}
    \item v funkciji lahko definiramo \textit{lokalne definicije}
    \item \textit{char} ima \textit{enojne} narekovaje, \textit{string} pa \textit{dvojne}
    \item lahko definiramo več stvari hkrati z \textit{and} \footnote{DIFFERENCE BETWEEN AND AND IN}
    \item deljenje je \textit{celoštevilsko} \footnote{za \textit{float} dodamo operatorju piko na konec}
    \item \textit{logične vrednosti} so tipa \textit{bool}
    \item če želimo funkcijo definirati \textit{po kosih}, uporabimo \textit{match}
    \item pri \textit{match} je \textit{vrstni red} pomemben
    \item \textit{rekurzivne funkcije} definiramo z \textit{let rec}
    \item \textit{nabore} pišemo kot \textit{n-terice}
    \item \textit{prazen nabor} imenujemo \textit{unit}
    \item \textit{seznami} so \textit{homogeni} \footnote{vsi elementi imajo \textit{enak} tip}
    \item z \textit{:: lepimo} sezname \footnote{funkcija je \textit{desno asociativna}}    
\end{itemize}
\newpage
\subsubsection*{\textit{funkcijsko programiranje}}
\begin{itemize}
    \item \textit{tipi} v OCamlu so navadno \textit{statični} \footnote{razlika med \textit{statičnimi} ali \textit{dinamičnimi} tipi je v tem, da se statični tipi preverijo, \textit{preden} se funkcija požene}
    \item OCaml ima od Pythona \textit{bogatejše tipe}
    \item klic funkcije je \textit{repen}, če se izvede \textit{zadnji}
    \item funkciji, kjer so vsi klici \textit{repno rekurzivni} pravimo \textit{repno rekurzivna funkcija}
    \item Python je \textit{proceduralni}\footnote{programe pišemo kot zaporedja ukazov} in \textit{imperativni}\footnote{z ukazi spreminjamo spremenljivke} jezik
    \item OCaml je \textit{funkcijski} in \textit{deklarativni}\footnote{opišemo stanje}
\end{itemize}
\subsubsection*{\textit{funkcije višjega reda}}
\textit{funkcije, ki sprejemajo druge funkcije}
\begin{itemize}
    \item če funkciji dveh elementov podamo zgolj en element, dobimo \textit{novo} funkcijo, ki \textit{še čaka} na drugi argument\footnote{f x y = (f x) y}
    \item postopek \textit{curryiranja} \footnote{PREVERI}
\end{itemize}
\subsubsection*{\textit{fold}}
\textit{fold right}
\begin{itemize}
    \item sprejme tri spremenljivke \footnote{naš seznam, začetno vrednost, funkcijo f}
    \item če imamo \textit{prazen seznam}, vrnemo \textit{začetno vrednost}, če je seznam tipa \textit{x :: xs}, funkcijo rekurzivno uporabimo na tem repu in tej vrednosti dodamo \textit{x}
\end{itemize}
\textit{fold left}
\begin{itemize}
    \item repno rekurzivna
\end{itemize}
\end{document}